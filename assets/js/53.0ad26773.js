(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{591:function(_,v,t){"use strict";t.r(v);var d=t(8),p=Object(d.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[_._v("sCrypt是比特币合约走出来的第一步。我们打开sCrypt的P2PKH合约的盒子，看看它是否真的工作。")]),_._v(" "),t("p",[_._v("基本操作请参考下面的文章\n"),t("a",{attrs:{href:"https://blog.csdn.net/freedomhero/article/details/107235041",target:"_blank",rel:"noopener noreferrer"}},[_._v("比特币智能合约入门（4）- sCrypt 合约实战篇 - P2PKH 合约化"),t("OutboundLink")],1)]),_._v(" "),t("p",[_._v("下面分析它生成的脚本是否正确。")]),_._v(" "),t("blockquote",[t("p",[_._v("这里使用的sCrypt 编译器版本是0.1.22，最新的编译器版本结果不同，请自行分析")])]),_._v(" "),t("p",[_._v("通过log显示了构造出来的锁定脚本为")]),_._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[_._v("  "),t("span",{pre:!0,attrs:{class:"token string"}},[_._v("'OP_1 40 00 51 b1 b2 OP_NOP $pubKeyHash OP_0 OP_1 OP_PICK OP_1 OP_ROLL OP_DROP OP_NOP OP_8 OP_PICK OP_HASH160 OP_1 OP_PICK OP_EQUAL OP_VERIFY OP_9 OP_PICK OP_9 OP_PICK OP_CHECKSIG OP_NIP OP_NIP OP_NIP OP_NIP OP_NIP OP_NIP OP_NIP OP_NIP OP_NIP OP_NIP'")]),_._v("\n")])])]),t("p",[_._v("这同标准脚本"),t("code",[_._v("OP_DUP OP_HASH160 $pubKeyHash OP_EQUALVERIFY OP_CHECKSIG")]),_._v("并不一致。两段脚本是否等价呢？")]),_._v(" "),t("p",[_._v("所有的脚本操作符的含义请参见 "),t("a",{attrs:{href:"https://blog.csdn.net/weixin_47461167/article/details/108278999",target:"_blank",rel:"noopener noreferrer"}},[_._v("比特币交易脚本语言操作符，常量和符号"),t("OutboundLink")],1)]),_._v(" "),t("p",[_._v("P2PKH解锁的时候需要一个签名 "),t("code",[_._v("sig")]),_._v(" 和一个公钥 "),t("code",[_._v("pk")]),_._v("\n为了说明更容易，先在堆栈中放入 sig pk")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("操作符")]),_._v(" "),t("th",[_._v("意思")]),_._v(" "),t("th",[_._v("堆栈（右侧是栈顶）")])])]),_._v(" "),t("tbody",[t("tr",[t("td"),_._v(" "),t("td",[_._v("解锁脚本入栈")]),_._v(" "),t("td",[_._v("sig pk")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_1'")]),_._v(" "),t("td",[_._v("将数字1入栈")]),_._v(" "),t("td",[_._v("sig pk 1")])]),_._v(" "),t("tr",[t("td",[_._v("'40'")]),_._v(" "),t("td",[_._v("将0x40入栈")]),_._v(" "),t("td",[_._v("sig pk 1 40")])]),_._v(" "),t("tr",[t("td",[_._v("'00'")]),_._v(" "),t("td",[_._v("入栈")]),_._v(" "),t("td",[_._v("sig pk 1 40 00")])]),_._v(" "),t("tr",[t("td",[_._v("'51'")]),_._v(" "),t("td",[_._v("入栈")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51")])]),_._v(" "),t("tr",[t("td",[_._v("'b1'")]),_._v(" "),t("td",[_._v("入栈")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1")])]),_._v(" "),t("tr",[t("td",[_._v("'b2'")]),_._v(" "),t("td",[_._v("入栈")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_NOP'")]),_._v(" "),t("td",[_._v("什么也不做")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2")])]),_._v(" "),t("tr",[t("td",[_._v("'b4...9d'")]),_._v(" "),t("td",[_._v("入栈公钥哈希, 20个字节")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_0'")]),_._v(" "),t("td",[_._v("空字节入栈")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh empty")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_1'")]),_._v(" "),t("td",[_._v("1 入栈")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh empty 1")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_PICK'")]),_._v(" "),t("td",[_._v("把堆栈的第1 个元素拷贝到栈顶（去掉1之后的栈顶是empty，它是第0个元素，那第一个元素就是pkh）")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh empty pkh")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_1'")]),_._v(" "),t("td",[_._v("1 入栈")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh empty pkh 1")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_ROLL'")]),_._v(" "),t("td",[_._v("把堆栈的第1 个元素移动到栈顶")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh pkh empty")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_DROP'")]),_._v(" "),t("td",[_._v("删除栈顶元素")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh pkh")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_NOP'")]),_._v(" "),t("td",[_._v("无操作")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh pkh")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_8'")]),_._v(" "),t("td",[_._v("数字8 入栈")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh pkh 8")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_PICK'")]),_._v(" "),t("td",[_._v("把堆栈的第8 个元素拷贝到栈顶")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh pkh pk")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_HASH160'")]),_._v(" "),t("td",[_._v("对斩顶的pk计算哈希")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh pkh pkh2")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_1'")]),_._v(" "),t("td",[_._v("1 入栈")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh pkh pkh2 1")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_PICK'")]),_._v(" "),t("td",[_._v("把堆栈的第1个元素拷贝到栈顶")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh pkh pkh2 pkh")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_EQUAL'")]),_._v(" "),t("td",[_._v("栈顶的两个元素判断是否相等")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh pkh true")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_VERIFY'")]),_._v(" "),t("td",[_._v("检查栈顶元素是否为真")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh pkh true")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_9'")]),_._v(" "),t("td",[_._v("10进制9入栈")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh pkh 9")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_PICK'")]),_._v(" "),t("td",[_._v("把堆栈的第9个元素拷贝到栈顶")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh pkh sig")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_9'")]),_._v(" "),t("td",[_._v("10进制9入栈")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh pkh sig 9")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_PICK'")]),_._v(" "),t("td",[_._v("把堆栈的第9 个元素拷贝到栈顶")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh pkh sig pk")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_CHECKSIG'")]),_._v(" "),t("td",[_._v("检查栈顶两个元素的签名")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh pkh true")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_NIP'")]),_._v(" "),t("td",[_._v("删除栈顶的下一个元素")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 pkh true")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_NIP'")]),_._v(" "),t("td",[_._v("删除栈顶的下一个元素")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 b2 true")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_NIP'")]),_._v(" "),t("td",[_._v("删除栈顶的下一个元素")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 b1 true")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_NIP'")]),_._v(" "),t("td",[_._v("删除栈顶的下一个元素")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 51 true")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_NIP'")]),_._v(" "),t("td",[_._v("删除栈顶的下一个元素")]),_._v(" "),t("td",[_._v("sig pk 1 40 00 true")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_NIP'")]),_._v(" "),t("td",[_._v("删除栈顶的下一个元素")]),_._v(" "),t("td",[_._v("sig pk 1 40 true")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_NIP'")]),_._v(" "),t("td",[_._v("删除栈顶的下一个元素")]),_._v(" "),t("td",[_._v("sig pk 1 true")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_NIP'")]),_._v(" "),t("td",[_._v("删除栈顶的下一个元素")]),_._v(" "),t("td",[_._v("sig pk true")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_NIP'")]),_._v(" "),t("td",[_._v("删除栈顶的下一个元素")]),_._v(" "),t("td",[_._v("sig true")])]),_._v(" "),t("tr",[t("td",[_._v("'OP_NIP'")]),_._v(" "),t("td",[_._v("删除栈顶的下一个元素")]),_._v(" "),t("td",[_._v("true")])])])]),_._v(" "),t("p",[_._v("到此脚本结束，栈顶返回true，正常解锁")]),_._v(" "),t("p",[_._v("这段脚本比标准脚本"),t("code",[_._v("OP_DUP OP_HASH160 $pubKeyHash OP_EQUALVERIFY OP_CHECKSIG")]),_._v("多了一些无用的操作符。但是等价。多出来的操作符应该是脚本语言占位所需，另也许有代码混淆的目的。")]),_._v(" "),t("p",[_._v("每一笔带satoshi的锁定输出，都需要解锁才能花费。锁定部分，在某个交易中的位置叫做 outpoint， 包括其所在的交易"),t("code",[_._v("txid")]),_._v("和位置"),t("code",[_._v("outputIndex")]),_._v(" 。对下一次花费来说，这个outpoint就是UTXO\n花费的时候需要数据服务商或者钱包可以找到这个UTXO。如果脚本可变，找到某个地址对应的UTXO需要设计算法。")]),_._v(" "),t("p",[_._v("目前"),t("a",{attrs:{href:"https://developers.whatsonchain.com/#get-unspent-transactions",target:"_blank",rel:"noopener noreferrer"}},[_._v("whatsonchain"),t("OutboundLink")],1),_._v("支持sCrypt版本P2PKH合约脚本的获取。")]),_._v(" "),t("p",[_._v("脚本类型的不同，对钱包如何提供解锁脚本也是一个挑战。")]),_._v(" "),t("blockquote",[t("p",[_._v("比特币带来的安全自由， 关注使用"),t("a",{attrs:{href:"https://note.sv",target:"_blank",rel:"noopener noreferrer"}},[_._v("NoteSV"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=p.exports}}]);